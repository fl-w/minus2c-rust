#![feature(or_patterns, in_band_lifetimes, drain_filter, bool_to_option)]

mod codegen;
mod eval;

use std::{
    fs::File,
    io::{Error, Write},
    path::PathBuf,
    process,
};

use argh::FromArgs;
use eval::{env::Env, object::Object};
use log::error;
use parser::{parse_stdin, parse_str, NodePtr};
use process::exit;
use rustyline::{error::ReadlineError, Editor};

#[derive(FromArgs)]
/// An implementation of the --C language in rust-lang.
struct Opt {
    /// input file, defaults to stdin.
    #[argh(positional)]
    input: Option<PathBuf>,
    /// whether to only run evaluation of given minus2c code.
    #[argh(switch, short = 'e')]
    eval: bool,
    /// run repl
    #[argh(switch)]
    repl: bool,
    /// output file, saves output to file at given path. defaults to {{input}}.s
    #[argh(option)]
    output: Option<PathBuf>,
    /// whether or not to print the parse tree (debug only)
    #[argh(switch)]
    print_tree: bool,
}

impl Opt {
    fn get_output(&self) -> Result<Box<dyn Write>, Error> {
        let output = &self.output;
        let input = &self.input;
        output
            .clone()
            .or_else(|| {
                input.clone().map(|path| {
                    let mut out = path;
                    out.set_extension("s");

                    out
                })
            })
            .map(|ref path| File::open(path).map(|f| Box::new(f) as Box<dyn Write>))
            .unwrap()
            .or_else(|_| Ok(Box::new(std::io::stdout())))
    }
}

fn repl() {
    // start repl
    println!(
        "Welcome to {} {} interpreter!",
        env!("CARGO_CRATE_NAME"),
        env!("CARGO_PKG_VERSION")
    );

    let mut rl = Editor::<()>::new();
    let mut env = Env::new();
    loop {
        let readline = rl.readline(">> ");
        match readline {
            Ok(line) => {
                if !line.is_empty() {
                    rl.add_history_entry(line.as_str());

                    match eval::eval_repl(line.as_str(), &mut env) {
                        Ok(result) => {
                            if result != Object::Void {
                                println!("{}", result)
                            }
                        }

                        Err(err) => println!("{}", err),
                    }
                }
            }
            Err(ReadlineError::Interrupted) => {
                println!("CTRL-C");
                break;
            }
            Err(ReadlineError::Eof) => break,
            Err(err) => {
                println!("Error: {:?}", err);
                break;
            }
        }
    }
}

fn main() {
    colog::init();

    let opt: Opt = argh::from_env();

    if opt.repl {
        repl()
    } else if let Some(root_node_ptr) = read_source_code(&opt.input) {
        // debug print tree
        if opt.print_tree {
            unsafe { parser::print_tree(root_node_ptr) };
        }

        if opt.eval {
            let rs = eval::eval_prog(root_node_ptr);
            let exit_code = match rs {
                Ok(Object::Int(return_code)) => return_code,
                Ok(Object::Void) => 0,
                Ok(_) => {
                    error!("minus2c: main returned non-int type");
                    1
                }

                Err(err) => {
                    error!("{}", err);
                    1
                }
            };

            exit(exit_code);
        } else {
            let mut output = opt.get_output().unwrap();
            let prog = codegen::compile_prog(root_node_ptr);

            log::debug!("{}", prog);

            writeln!(
                &mut output,
                "# {:^40}\n# {:^40}\n# \n",
                "This file was automatically generated by:",
                format_args!(
                    "{} compiler {}",
                    env!("CARGO_CRATE_NAME"),
                    env!("CARGO_PKG_VERSION")
                )
            )
            .and_then(|_| write!(output, "{}", prog))
            .unwrap()
        }
    } else {
        exit(1);
    }
}

fn read_source_code(input_path: &Option<PathBuf>) -> Option<NodePtr> {
    if let Some(input_path) = input_path {
        if !input_path.is_file() {
            println!("minus2c: no such file {:?}", input_path);
            None
        } else {
            let source =
                std::fs::read_to_string(input_path).expect("unable to read file contents.");

            parse_str(source.as_str())
        }
    } else {
        unsafe { parse_stdin() }
    }
}
